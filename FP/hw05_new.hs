module Hw05 where

-- 1. Дан список. Написать функцию, возвращающую список пар: элемент и его номер, т.е. f "abc" == [('a',0),('b',1),('c',2)]
-- a) При помощи рекурсии.

numlist :: [a] -> [(a, Int)]
numlist l = helper l 0 where
    helper [] _ = []
    helper (h:l) i = (h, i) : helper l (i + 1)
    

-- b) При помощи функции zip.

numlist' :: [a] -> [(a, Int)]
numlist' l = zip l [0..]

-- 2. Написать функцию fun :: [Int] -> [Int], которая четные числа в нечетных позициях (нумеруя с 0) умножает на 2, остальные не изменяет

fun :: [Int] -> [Int]
fun l = map f $ zip l [0..] where
    f (v, i) 
        | (even v) && (odd i) = v * 2
        | otherwise = v

-- 3. Реализовать reverse.
-- a) При помощи (++)
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (h:l) = reverse' l ++ [h]

-- b) При помощи аккумулирующего параметра.

-- Сравнить их время работы на списке [1..10000]
--4. Реализовать следующие функции, используя композицию:
-- a) nelem :: a -> [a] -> Bool, которая работает как функция notElem. Используйте функцию elem.

nelem :: a -> [a] -> Bool
nelem e l = not.elem e

-- b) f :: (Int -> Int) -> Int -> Bool. f g x должен возвращать True, если g x четен. Используйте функцию even.
-- c) f :: [Int] -> Bool. f xs возвращает True, если в xs есть хотя бы 1 положительное число, иначе False. Используйте функции filter и null.
-- d) f :: (a -> Bool) -> [a] -> Int. f p xs возвращает количество элементов в xs, не удовлетворяющих предикату p. Используйте функции filter и length.
-- e) f :: [Int] -> Int. f возвращает сумму первых 10 элементов списка.
-- f) f :: [Int] -> Int. f каждый элемент умножает на 2, потом прибавляет 3 и возвращает произведение всех элементов. f [1,2,3] == 315. Используйте функцию product.
-- 5. primes :: [Integer] -- бесконечный список простых чисел. Hint: напишите сначала функцию isPrime, проверяющую простоту числа.
-- 6. fibs :: [Integer] -- бесконечный список чисел фибоначчи.
-- 7. swap :: Int -> Int -> [a] -> [a] -- swap i j меняет местами i и j элементы. Например swap 1 2 [3,4,5,6] == [3,5,4,6]. swap 2 0 "abcd" == "cbad". 
-- 8. Задана рекурентная последовательность a(0) = 1, a(1) = 2, a(2) = 3, a(k+3) = a(k+2) + a(k) - 2*a(k+1). 
--    Написать функцию f :: Int -> Int. f i возвращает i элемент этой последовательности. f 
-- Должна работать линейное время. Нельзя использовать списки. Hint: используйте 
-- кортежи. 
